Title: Avatar
 * Sam Worthington
 * Zoe Saldana
 * Sigourney Weaver
 * Stephen Lang
 * Michelle Rodriguez
 * Giovanni Ribisi
 * Joel David Moore
 * CCH Pounder
 * Wes Studi
 * Laz Alonso
 * Dileep Rao
 * Matt Gerald
 * Sean Anthony Moran
 * Jason Whyte
 * Scott Lawrence
 * Kelly Kilgour
 * James Patrick Pitt
 * Sean Patrick Murphy
 * Peter Dillon
 * Kevin Dorman
 * Kelson Henderson
 * David Van Horn
 * Jacob Tomuri
 * Michael Blain-Rozgay
 * Jon Curry
 * Luke Hawker
 * Woody Schultz
 * Peter Mensah
 * Sonia Yee
 * Jahnel Curfman
 * Ilram Choi
 * Kyla Warren
 * Lisa Roumain
 * Debra Wilson
 * Chris Mala
 * Taylor Kibby
 * Jodie Landau
 * Julie Lamm
 * Cullen B. Madden
 * Joseph Brady Madden
 * Frankie Torres
 * Austin Wilson
 * Sara Wilson
 * Tamica Washington-Miller
 * Lucy Briant
 * Nathan Meister
 * Gerry Blair
 * Matthew Chamberlain
 * Paul Yates
 * Wray Wilson
 * James Gaylyn
 * Melvin Leno Clark III
 * Carvon Futrell
 * Brandon Jelkes
 * Micah Moch
 * Hanniyah Muhammad
 * Christopher Nolen
 * Christa Oliver
 * April Marie Thomas
 * Bravita A. Threatt
 * Colin Bleasdale
 * Mike Bodnar
 * Matt Clayton
 * Nicole Dionne
 * Jamie Harrison
 * Allan Henry
 * Anthony Ingruber
 * Ashley Jeffery
 * Dean Knowsley
 * Joseph Mika-Hunt
 * Terry Notary
 * Kai Pantano
 * Logan Pithyou
 * Stuart Pollock
 * Raja
 * Gareth Ruck
 * Rhian Sheehan
 * T. J. Storm
 * Jodie Taylor
 * Alicia Vela-Bailey
 * Richard Whiteside
 * Nikie Zambo
 * Julene Reneeni






 //hashmap type string and integer
     Map<String, Set<String>> actorHashMap = new HashMap<String, Set<String>>();
     int index;
     String sourceActor;
     String targetActor;
     Set<String> connectedActors = actorHashMap.get(sourceActor);
     //checks if source actor is connected to anyone
     public boolean findConnectedActor(){
         if(connectedActors.contains(sourceActor)) {
             return true;
         }
         return false;
     }



     //Integer depth = 1;
     //Set<String> actorsAddedAtCurrentDepth = actorHashMap.get(sourceActor);
     //Set<String> actorsAddedAtPrecedingDepth = actorsAddedAtCurrentDepth;
     //checks if source actor is connected to target actor
 //    public Integer findPath(){
 //        Map<String, Integer> connectedActorsAndDepth = new HashMap<String, Integer>();
 //        Set<String> actorsAddedAtCurrentDepth = actorHashMap.get(sourceActor);
 //        Set<String> actorsAddedAtPrecedingDepth = actorsAddedAtCurrentDepth;
 //        Integer depth = 1;
 //        for (String otherActor : actorsAddedAtPrecedingDepth) {
 //            if (otherActor.equals(targetActor)){
 //                return depth;
 //            }
 //            connectedActorsAndDepth.put(otherActor, depth);
 //        }
 //
 //        Integer maxDepth = 10;
 //        while (++depth < maxDepth) {
 //            actorsAddedAtCurrentDepth = new HashSet<String>();
 //            for (String otherActor : actorsAddedAtPrecedingDepth) {
 //                if (otherActor.equals(targetActor)){
 //                    return depth;
 //                }
 //                if (!connectedActorsAndDepth.contains(otherActor)) {
 //                    actorsAddedAtCurrentDepth.add(otherActor);
 //                    connectedActorsAndDepth.put(otherActor, depth);
 //                }
 //            }
 //            actorsAddedAtPrecedingDepth = actorsAddedAtCurrentDepth;
 //        }
 //        return depth;
 //    }

     //global index variable
     //string name of actor and integer is index
     //adjacency list array of actors with respect to variable source(index of list)
 //    LinkedList<String ,Integer> list[] = new LinkedList[];
 //    int vertex;
 //    public Movies(int vertex) {
 //        this.vertex = vertex;
 //        list = new LinkedList[vertex];
 //        for (int i = 0; i < vertex; i++) {
 //            list[i] = new LinkedList<>();
 //        }
 //    }
 //    public void addEdge(String actor, int index){
 //
 //        //add edge
 //        list[Integer.parseInt(actor)].addFirst(String.valueOf(index));
 //
 //        //add back edge ((for undirected)
 //        list[index].addFirst(actor);
 //    }
     //read in the file
     //function to to see if path is possible
     //function to find shortest path
     //check if actor A worked with actor b
